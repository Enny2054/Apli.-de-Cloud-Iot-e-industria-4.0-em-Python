#include <WiFi.h> // Biblioteca paraa conectar o esp32 a uma rede wifi
#include <HTTPClient.h> // Biblioteca para enviar requisições HTTP
#include <WiFiClientSecure.h>  // Biblioteca que permite conexões HTTPS

// Configurações dos pinos
#define TRIG_PIN 13
#define ECHO_PIN 12

// Configurações do alerta
float distMinimaCm = 30.0;   // Distância limite (cm)
bool alertaEnviado = false;  // Evita alertas repetidos

// Configuração do wi-fi
const char* ssid = "Wokwi-GUEST";
const char* password = "";

// URL do webhook
String urlDoWebhook = "https://canary.discord.com/api/webhooks/1435780967942983921/qoLg9I-c8EY51TbU5r-zNSOIWDOBhUJbXqDPcP_sjGUTFuzE9gEixce40yq3ZrNXnGKz";

// Função para calcular distância
float lerDistanciaCm() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(5);

  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  long duration = pulseIn(ECHO_PIN, HIGH, 30000);
  if (duration == 0) {
    return -1.0;
  }

  float distance = (duration * 0.0343) / 2.0;
  return distance;
}

// Função para enviar alerta para nuvem
void enviarAlertaParaNuvem() {
  if (WiFi.status() == WL_CONNECTED) {
    WiFiClientSecure client;
    client.setInsecure();
    HTTPClient http;

    Serial.println("Enviando alerta para o Discord...");
    http.begin(client, urlDoWebhook.c_str());
    http.addHeader("Content-Type", "application/json");

    String corpoDaMensagem = "{\"content\":\"@everyone ALERTA DE FOSSA CHEIA! O sensor detectou que está perto do nível máximo!\"}";

    int httpCode = http.POST(corpoDaMensagem);
    if (httpCode > 0) {
      Serial.printf("[HTTP] Codigo: %d\n", httpCode);
      if (httpCode >= 200 && httpCode < 300) {
        Serial.println("[HTTP] Alerta enviado com sucesso!");
      } else {
        Serial.printf("[HTTP] Falha ao enviar (status %d): %s\n", httpCode, http.getString().c_str());
      }
    } else {
      Serial.printf("[HTTP] Erro ao conectar: %s\n", http.errorToString(httpCode).c_str());
    }

    http.end();
  } else {
    Serial.println("Erro: sem conexao Wi-Fi.");
  }
}
// Executa apenas uma vez quando o esp32 liga
void setup() {
  Serial.begin(115200);
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  digitalWrite(TRIG_PIN, LOW);

  Serial.println("Conectando ao Wi-Fi...");
  WiFi.begin(ssid, password);
  unsigned long startAttempt = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
    if (millis() - startAttempt > 20000) {
      Serial.println("\nFalha ao conectar Wi-Fi (timeout).");
      break;
    }
  }
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nConectado ao Wi-Fi!");
    Serial.println(WiFi.localIP());
  }
}
// Função de loop
void loop() {
  float distanciaAtual = lerDistanciaCm();

  if (distanciaAtual < 0 || distanciaAtual > 400) {
    Serial.println("Leitura invalida do sensor. Tentando novamente...");
    delay(2000);
    return;
  }

  Serial.print("Distancia medida: ");
  Serial.print(distanciaAtual);
  Serial.println(" cm");

  if (distanciaAtual < distMinimaCm) {
    if (!alertaEnviado) {
      enviarAlertaParaNuvem();
      alertaEnviado = true;
    } else {
      Serial.println("(Fossa cheia, mas alerta ja foi enviado)");
    }
  } else {
    if (alertaEnviado) {
      Serial.println("Nivel normalizado, resetando alerta.");
      alertaEnviado = false;
    } else {
      Serial.println("Nivel dentro do normal.");
    }
  }

  delay(5000);
}
